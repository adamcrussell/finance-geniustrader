package GT::Indicators::Generic::ByName;

# Copyright 2000-2002 Raphaël Hertzog, Oliver Bossert
# Corrections and documention Copyright 2008 Thomas Weigert
# This file is distributed under the terms of the General Public License
# version 2 or (at your option) any later version.

# $Id$

# Standards-Version: 1.0

use strict;
use vars qw(@ISA @NAMES @DEFAULT_ARGS);

use GT::Indicators;
use GT::Prices;

@ISA = qw(GT::Indicators);
@NAMES = ("ByName[#*]");
@DEFAULT_ARGS = ("");

=head2 NAME

GT::Indicators::Generic::ByName - Alias to another indicator

=head2 DESCRIPTION

Sometimes, during the computation of an indicator, one needs to reference
the current value of a series that is being computed by this indicator.
If the current indicator is used explicity, an infinite recursion arises
due to the dependency mechanism.

This indicator resolves the recursion. This indicator is nothing more than
an alias of a seried calculated by an indicator. Just give as first parameter
the name of the value to use.

This indicator is used when, during the calculation of an indicator,
an intermediate series wants to leverage another intermediate series
or an output value.

For example,
    $self->{'sma1'} = GT::Indicators::SMA->new([ $self->{'args'}->get_arg_names(1), $self->{'args'}->get_arg_names(2) ]);
    $self->{'sma2'} = GT::Indicators::SMA->new([ $self->{'args'}->get_arg_names(1), "{I:Generic:ByName " . $self->{'sma1'}->get_name . "}" ]);

The first line defines an intermediate series which smoothes the
second parameter. The second line takes that series and applies 
smoothing again. Similarly, the following applies smoothing to
the first output value.
    $self->{'sma3'} = GT::Indicators::SMA->new([ $self->{'args'}->get_arg_names(1), "{I:Generic:ByName " . $self->get_name(0) . "}" ]);

Care has to be taken that I:Generic:ByName is in fact given the
name of an indicator, lest that series will not be found. The get_name
method will always retrieve the name of a series. The parsable syntax
does yield a name also.

***FIXME***
The name as generated by the ArgsTree::parse_args is rather
brittle and needs to be fixed up as indicated in the comments
embedded in this modules code. Additional problems might exist.


=cut

sub new {
    my ($type, $args, $key) = @_;
    my $class = ref($type) || $type;
    my $self = { };
    no strict "refs";
    # Note: Do not add any cruft (e.g., whitespace) when joining the
    # argument list, otherwise the constructed name will differ from
    # the name of the referenced series.
    #$self->{'args'}->[0] = join('', @{$args});

    my $out =  '';
    foreach (@{$args}) {
      $out .= $_;
      $out .= ' ' if ($_ =~ /[a-zA-Z0-9]$/o);
    }
    # Note: line 333 of ArgsTree.pm inserts extra \s before opening brace
    # However, when CacheValues are set, these extra \s are not present in name
    # Remove. 
    $out =~ s/(\s)+/$1/go;
    $self->{'args'}->[0] = $out;

    return manage_object(\@{"$class\::NAMES"}, $self, $class, $self->{'args'}, $key);
}

sub initialize {
    my ($self) = @_;
}


sub calculate {
    my ($self, $calc, $i) = @_;
    my $indic = $calc->indicators;
    my $name = $self->get_name(0);

    my @pars = ();
    my $parname = $self->{'args'}->[0];

    #print "ByName($i): $parname = " . (($indic->is_available($parname, $i))?$indic->get($parname, $i):'') . "\n";

    $indic->set($name, $i, $indic->get($parname, $i))
     if ($indic->is_available($parname, $i));

}

1;
